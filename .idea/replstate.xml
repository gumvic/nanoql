<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1456920604444">{:repl-history {:ide [], :local [&quot;(s/validate nil nil)&quot; &quot;(s/validate foo 123)&quot; &quot;(s/validate PropSchema 123)&quot; &quot;(s/validate PropSchema [])&quot; &quot;s/fn&quot; &quot;(def foo 123)&quot; &quot;#'nanoql.core/foo&quot; &quot;var?&quot; &quot;(var? #'nanoql.core/foo)&quot; &quot;@#'nanoql.core/foo&quot; &quot;(s/if s/Any s/Any s/Any)&quot; &quot;(s/validate (s/if s/Any s/Any s/Any) 12)&quot; &quot;(var? foo)&quot; &quot;(var? #'foo)&quot; &quot;@#'foo&quot; &quot;var&quot; &quot;(def bar [bar])&quot; &quot;bar&quot; &quot;(first bar)&quot; &quot;(bound? (first bar))&quot; &quot;s/enum&quot; &quot;(doc 's/enum)&quot; &quot;'s/enum&quot; &quot;(resolve 's/enum)&quot; &quot;(doc doc)&quot; &quot;(doc s/enum)&quot; &quot;(s/validate (s/enum s/Keyword s/Int) 123)&quot; &quot;s/either&quot; &quot;(s/either s/Keyword s/String)&quot; &quot;(s/either s/Keyword s/Str)&quot; &quot;(s/validate (s/either s/Keyword s/Str) 123)&quot; &quot;(s/validate (s/either s/Keyword s/Str) :foo)&quot; &quot;(seq? #{})&quot; &quot;(coll? #{})&quot; &quot;(require '(nanoql.core))&quot; &quot;(doc nanoql.core/query)&quot; &quot;(validate s/Query 123)&quot; &quot;(validate s/Schema 123)&quot; &quot;(validate s/Query [{} {}])&quot; &quot;Name&quot; &quot;Query&quot; &quot;(s/validate Query 123)&quot; &quot;(s/validate Name 123)&quot; &quot;(s/validate Name [])&quot; &quot;(s/validate Args 123)&quot; &quot;(s/validate Args {})&quot; &quot;(s/validate Props {})&quot; &quot;(def foo {})&quot; &quot;foo&quot; &quot;Args&quot; &quot;Props&quot; &quot;(s/validate Props nil)&quot; &quot;(require '[nanoql.ql :as ql])&quot; &quot;(ql/compile 123)&quot; &quot;nq.s/Query-Root&quot; &quot;(dos s/validate)&quot; &quot;(doc s/validate)&quot; &quot;(s/validate nq.s/Query-Root [{} {}])&quot; &quot;(s/validate nq.s/Query-Root {})&quot; &quot;(ql/compile [])&quot; &quot;(s/validate nq.s/Query-Root (ql/compile []))&quot; &quot;123&quot; &quot;(require '[nanoql.core.schema :as nq.s])&quot; &quot;(s/validate nq.s/Schema-Root nil)&quot; &quot;[require '[nanoql.core :as nq]]&quot; &quot;(require '[nanoql.core :as nq])&quot; &quot;(nq/query nil nil [{} {}])&quot; &quot;(require 'schema.core)&quot; &quot;schema.core/Any&quot; &quot;(map? schema.core/Any)&quot; &quot;(map? schema.core/Num)&quot; &quot;(= schema.core/Any {})&quot; &quot;(for [[p v] schema.core/Any] [p v])&quot; &quot;(schema.core/validate \n  {:users []}\n  {:users []})&quot; &quot;(schema.core/validate \n  {(schema.core/optional-key :users) []}\n  {:users []})&quot; &quot;(require 'clojure.core.async :as a)&quot; &quot;(apply (partial into {}) [[1 2] [2 3]])&quot; &quot;(into {} [[1 2] [2 3]])&quot; &quot;(require '[schema.core :a s])&quot; &quot;(require '[schema.core :as s])&quot; &quot;(def S s/Any)&quot; &quot;(s/recursive #'S)&quot; &quot;(map? (s/recursive #'S))&quot; &quot;(keys (s/recursive #'S))&quot; &quot;(require '[clojure.core.async])&quot; &quot;(require '[clojure.core.async :as a])&quot; &quot;(/ 1 0)&quot; &quot;(a/poll! (go 123))&quot; &quot;(a/poll! (a/go 123))&quot; &quot;(a/poll! (a/go (/ 1 0)))&quot; &quot;(defn ok [ch x]\n  (a/put! ch x))&quot; &quot;(defn error [ch err]\n  (a/put! ch (Exception. err)))&quot; &quot;(defn error? [x]\n  (instance? Exception x))&quot; &quot;(defn prom []\n  (a/promise-chan\n    (map\n      (fn [x]\n        (if (error? x)\n          (throw x)\n          x)))))&quot; &quot;(Exception. 123)&quot; &quot;(Exception. \&quot;error\&quot;)&quot; &quot;(defn error [ch err]\n  (a/put! ch (Exception. (.toString err))))&quot; &quot;(let [ch (prom)]\n  (error ch 123))&quot; &quot;(let [ch (prom)]\n  (try\n    (error ch 123)\n    (catch e)))&quot; &quot;(defn prom []\n  (a/promise-chan\n    (map\n      (fn [x]\n        (if (error? x)\n          (throw x)\n          x)))\n    println))&quot; &quot;(let [ch (prom)]\n  (try\n    (error ch 123)\n    (catch Exception e)))&quot;], :remote []}}</component>
</project>