<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1456772209421">{:repl-history {:ide [], :local [&quot;(nth {} 0)&quot; &quot;(nanoql.impl.query/compile [: foo :bar])&quot; &quot;(nanoql.impl.query/compile [:foo :bar])&quot; &quot;56&quot; &quot;schema.core/validate&quot; &quot;query&quot; &quot;nanoql.core/query&quot; &quot;*ns*&quot; &quot;(s/validate {} 123)&quot; &quot;(s/validate [1 2] [])&quot; &quot;(s/validate [{}] [])&quot; &quot;(s/validate (s/pred (fn [x] (= (count x) 2))) [])&quot; &quot;(s/check 1 2)&quot; &quot;(s/check [] 2)&quot; &quot;s/validate&quot; &quot;(s/validate [s/one {}] {})&quot; &quot;(s/validate [(s/one {} \&quot;args\&quot;)] {})&quot; &quot;(s/validate [(s/one {} \&quot;args\&quot;)] [])&quot; &quot;(s/validate [(s/one {} \&quot;args\&quot;)] [1])&quot; &quot;(s/validate [(s/one {} \&quot;args\&quot;)] [{}])&quot; &quot;(s/validate [(s/one {} \&quot;args\&quot;)] [{} {}])&quot; &quot;(sequential? {})&quot; &quot;(sequential? [])&quot; &quot;(s/validate [] {})&quot; &quot;(s/validate {s/Any 123} {})&quot; &quot;(s/validate {s/Any s/Int} {})&quot; &quot;(s/validate {s/Any s/Int} {1 2 3 3})&quot; &quot;(s/validate {s/Any s/Int} {1 2 3 :ddd})&quot; &quot;(s/validate QuerySchema {})&quot; &quot;(s/validate QuerySchema [{} {}])&quot; &quot;(s/validate QuerySchema [{} {1 2}])&quot; &quot;#'foo&quot; &quot;(s/validate QuerySchema [{} {:id nil}])&quot; &quot;(s/validate nil nil)&quot; &quot;(s/validate foo 123)&quot; &quot;(s/validate PropSchema 123)&quot; &quot;(s/validate PropSchema [])&quot; &quot;s/fn&quot; &quot;(def foo 123)&quot; &quot;#'nanoql.core/foo&quot; &quot;var?&quot; &quot;(var? #'nanoql.core/foo)&quot; &quot;@#'nanoql.core/foo&quot; &quot;(s/if s/Any s/Any s/Any)&quot; &quot;(s/validate (s/if s/Any s/Any s/Any) 12)&quot; &quot;(var? foo)&quot; &quot;(var? #'foo)&quot; &quot;@#'foo&quot; &quot;var&quot; &quot;(def bar [bar])&quot; &quot;bar&quot; &quot;(first bar)&quot; &quot;(bound? (first bar))&quot; &quot;s/enum&quot; &quot;(doc 's/enum)&quot; &quot;'s/enum&quot; &quot;(resolve 's/enum)&quot; &quot;(doc doc)&quot; &quot;(doc s/enum)&quot; &quot;(s/validate (s/enum s/Keyword s/Int) 123)&quot; &quot;s/either&quot; &quot;(s/either s/Keyword s/String)&quot; &quot;(s/either s/Keyword s/Str)&quot; &quot;(s/validate (s/either s/Keyword s/Str) 123)&quot; &quot;(s/validate (s/either s/Keyword s/Str) :foo)&quot; &quot;(seq? #{})&quot; &quot;(coll? #{})&quot; &quot;(require '(nanoql.core))&quot; &quot;(doc nanoql.core/query)&quot; &quot;(validate s/Query 123)&quot; &quot;(validate s/Schema 123)&quot; &quot;(validate s/Query [{} {}])&quot; &quot;Name&quot; &quot;Query&quot; &quot;(s/validate Query 123)&quot; &quot;(s/validate Name 123)&quot; &quot;(s/validate Name [])&quot; &quot;(s/validate Args 123)&quot; &quot;(s/validate Args {})&quot; &quot;(s/validate Props {})&quot; &quot;(def foo {})&quot; &quot;foo&quot; &quot;Args&quot; &quot;Props&quot; &quot;(s/validate Props nil)&quot; &quot;(require '[nanoql.ql :as ql])&quot; &quot;(ql/compile 123)&quot; &quot;nq.s/Query-Root&quot; &quot;(dos s/validate)&quot; &quot;(doc s/validate)&quot; &quot;(s/validate nq.s/Query-Root [{} {}])&quot; &quot;(s/validate nq.s/Query-Root {})&quot; &quot;(ql/compile [])&quot; &quot;(s/validate nq.s/Query-Root (ql/compile []))&quot; &quot;123&quot; &quot;(require '[nanoql.core.schema :as nq.s])&quot; &quot;(require '[schema.core :as s])&quot; &quot;(s/validate nq.s/Schema-Root nil)&quot; &quot;[require '[nanoql.core :as nq]]&quot; &quot;(require '[nanoql.core :as nq])&quot; &quot;(nq/query nil nil [{} {}])&quot;], :remote []}}</component>
</project>